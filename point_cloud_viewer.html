<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Point Cloud Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #f0f0f0;
        }
        #container {
            width: 100%;
            height: 600px;
            border: 2px solid #333;
            border-radius: 8px;
            background: #000;
            position: relative;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 100;
        }
        #controls {
            margin-bottom: 20px;
        }
        button {
            padding: 10px 15px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            background: #007acc;
            color: white;
            cursor: pointer;
        }
        button:hover {
            background: #005a99;
        }
        #fileInput {
            margin: 10px 0;
        }
        #stats {
            margin-top: 10px;
            padding: 10px;
            background: white;
            border-radius: 5px;
            border: 1px solid #ddd;
        }
    </style>
</head>
<body>
    <h1>Point Cloud Viewer</h1>
    <div id="controls">
        <input type="file" id="fileInput" accept=".csv" />
        <button onclick="loadDefaultData()">Load Indoor Room Data</button>
        <button onclick="resetView()">Reset View</button>
        <button onclick="toggleLabels()">Toggle Label Colors</button>
    </div>

    <div id="container">
        <div id="info">
            Mouse: Left click + drag to rotate<br/>
            Wheel: Zoom in/out<br/>
            Right click + drag: Pan
        </div>
    </div>

    <div id="stats">
        <div id="pointCount">Points loaded: 0</div>
        <div id="labelInfo">Labels: Not loaded</div>
    </div>

    <script>
        let scene, camera, renderer, controls, pointCloud;
        let useSemanticColors = true;

        // Semantic label color mapping
        const labelColors = {
            1.0: [0.8, 0.2, 0.2], // Red
            2.0: [0.2, 0.8, 0.2], // Green
            3.0: [0.2, 0.2, 0.8], // Blue
            4.0: [0.8, 0.8, 0.2], // Yellow
            5.0: [0.8, 0.2, 0.8], // Magenta
            6.0: [0.2, 0.8, 0.8], // Cyan
            7.0: [0.8, 0.5, 0.2], // Orange
            8.0: [0.5, 0.8, 0.2], // Lime
            9.0: [0.2, 0.5, 0.8], // Sky blue
            10.0: [0.8, 0.2, 0.5] // Pink
        };

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / 600, 0.1, 1000);
            camera.position.set(0, 0, 10);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(document.getElementById('container').clientWidth, 600);
            document.getElementById('container').appendChild(renderer.domElement);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.1;
            controls.enableZoom = true;
            controls.enablePan = true;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            // Handle window resize
            window.addEventListener('resize', onWindowResize);

            animate();
        }

        function onWindowResize() {
            camera.aspect = document.getElementById('container').clientWidth / 600;
            camera.updateProjectionMatrix();
            renderer.setSize(document.getElementById('container').clientWidth, 600);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function parseCSV(csvText) {
            const lines = csvText.split('\n').filter(line => line.trim());
            const header = lines[0].split(';');
            const points = [];

            // Find column indices
            const xIdx = header.indexOf('x');
            const yIdx = header.indexOf('y');
            const zIdx = header.indexOf('z');
            const rIdx = header.indexOf('R');
            const gIdx = header.indexOf('G');
            const bIdx = header.indexOf('B');
            const labelIdx = header.indexOf('semantic_label');

            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(';');
                if (values.length >= header.length) {
                    points.push({
                        x: parseFloat(values[xIdx]),
                        y: parseFloat(values[yIdx]),
                        z: parseFloat(values[zIdx]),
                        r: parseInt(values[rIdx]),
                        g: parseInt(values[gIdx]),
                        b: parseInt(values[bIdx]),
                        label: parseFloat(values[labelIdx])
                    });
                }
            }

            return points;
        }

        function createPointCloud(points) {
            if (pointCloud) {
                scene.remove(pointCloud);
            }

            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(points.length * 3);
            const colors = new Float32Array(points.length * 3);

            // Get unique labels for info
            const uniqueLabels = [...new Set(points.map(p => p.label))];
            document.getElementById('labelInfo').textContent = `Labels: ${uniqueLabels.sort().join(', ')}`;

            for (let i = 0; i < points.length; i++) {
                const point = points[i];

                // Positions
                positions[i * 3] = point.x;
                positions[i * 3 + 1] = point.y;
                positions[i * 3 + 2] = point.z;

                // Colors
                if (useSemanticColors && labelColors[point.label]) {
                    colors[i * 3] = labelColors[point.label][0];
                    colors[i * 3 + 1] = labelColors[point.label][1];
                    colors[i * 3 + 2] = labelColors[point.label][2];
                } else {
                    // Use original RGB colors
                    colors[i * 3] = point.r / 255;
                    colors[i * 3 + 1] = point.g / 255;
                    colors[i * 3 + 2] = point.b / 255;
                }
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.02,
                vertexColors: true,
                sizeAttenuation: true
            });

            pointCloud = new THREE.Points(geometry, material);
            scene.add(pointCloud);

            // Center the view
            geometry.computeBoundingBox();
            const center = geometry.boundingBox.getCenter(new THREE.Vector3());
            controls.target.copy(center);

            // Update stats
            document.getElementById('pointCount').textContent = `Points loaded: ${points.length}`;

            // Adjust camera position based on bounding box
            const size = geometry.boundingBox.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            camera.position.copy(center);
            camera.position.z += maxDim * 2;

            controls.update();
        }

        function loadDefaultData() {
            fetch('./DATA/indoor_room_labelled_minimal.csv')
                .then(response => response.text())
                .then(csvText => {
                    const points = parseCSV(csvText);
                    createPointCloud(points);
                })
                .catch(error => {
                    console.error('Error loading file:', error);
                    alert('Could not load the default data file. Make sure the DATA folder is accessible.');
                });
        }

        function resetView() {
            if (pointCloud) {
                const geometry = pointCloud.geometry;
                geometry.computeBoundingBox();
                const center = geometry.boundingBox.getCenter(new THREE.Vector3());
                const size = geometry.boundingBox.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);

                camera.position.copy(center);
                camera.position.z += maxDim * 2;
                controls.target.copy(center);
                controls.update();
            }
        }

        function toggleLabels() {
            if (pointCloud) {
                useSemanticColors = !useSemanticColors;
                const geometry = pointCloud.geometry;
                const positions = geometry.getAttribute('position').array;
                const colors = geometry.getAttribute('color').array;

                // We need to recreate with the current points data
                // For now, just reload the default data
                loadDefaultData();
            }
        }

        // File input handler
        document.getElementById('fileInput').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const csvText = e.target.result;
                    const points = parseCSV(csvText);
                    createPointCloud(points);
                };
                reader.readAsText(file);
            }
        });

        // Initialize
        init();
    </script>
</body>
</html>